# sqrtPriceX96 参数详解

`sqrtPriceX96` 是 Uniswap v3/v4 中表示**当前价格**的核心参数。

---

## 完整定义

```
sqrtPriceX96 = √(token1/token0) × 2^96
```

拆解来看：

```
实际价格 P = token1数量 / token0数量

sqrtPriceX96 = sqrt(P) × 2^96
             = √(token1/token0) × 79228162514264337593543950336
```

---

## 为什么存的是"价格的平方根"而不是价格本身？

因为 AMM 核心公式是 `x × y = k`，流动性 `L = sqrt(k) = sqrt(x×y)`。

在集中流动性计算中，**token 数量 Δx、Δy 与 sqrtPrice 呈线性关系**：

```
Δy = L × (sqrtP_upper - sqrtP_lower)
Δx = L × (1/sqrtP_lower - 1/sqrtP_upper)
```

存 sqrtPrice 而不是 price，让这些计算变成简单的加减乘除，**避免了开平方运算**，节省大量 gas。

---

## 为什么乘以 `2^96`？

Solidity 里没有浮点数，`sqrt(P)` 通常是小数（比如 ETH/USDC 价格 √(1000) ≈ 31.6）。

乘以 `2^96`（即 **Q64.96 定点数**格式）把小数转为整数存储：

```
√(1000) × 2^96 ≈ 2505414483750479311864138015...（一个很大的整数）
```

- 高 64 位保存整数部分
- 低 96 位保存小数精度

这保证了 uint160 范围（sqrtPriceX96 用 uint160 存储）能覆盖所有合理价格范围，精度达到小数点后约 28 位。

---

## 常见使用场景

### 初始化池子时

```solidity
// 表示 token0:token1 = 1:1 的价格
uint160 constant SQRT_PRICE_1_1 = 79228162514264337593543950336; // = 1 × 2^96

// 表示价格 1:4（sqrtPrice = 0.5）
uint160 constant SQRT_PRICE_1_4 = 39614081257132168796771975168; // = 0.5 × 2^96
```

### 如何反推出实际价格

```solidity
// 给定 sqrtPriceX96，反推价格
uint256 price = (uint256(sqrtPriceX96) * sqrtPriceX96) >> 192;
//                          ↑ 先平方去掉 sqrt          ↑ 除以 2^192（即 (2^96)^2）
```

### 在 Slot0 中的存储位置

```
Slot0（256 bits）:
┌──────┬──────────┬───────────────┬──────────┬────────────────────────┐
│  空  │ lpFee:24 │ protocolFee:24│ tick:24  │  sqrtPriceX96 : 160    │
└──────┴──────────┴───────────────┴──────────┴────────────────────────┘
```

160 位恰好能存下 sqrtPriceX96 的最大值（对应 MAX_TICK 的价格）。

---

## 实际数值对照

| 价格（token1/token0） | sqrtPrice | sqrtPriceX96（近似） |
|---|---|---|
| 1：1 | 1.0 | `2^96` ≈ 7.92×10^28 |
| 1：4 | 0.5 | `0.5 × 2^96` |
| 100：1 | 10.0 | `10 × 2^96` |
| ETH/USDC ≈ 3000 | 54.77 | `54.77 × 2^96` |

---

## 一句话总结

> `sqrtPriceX96` 是 `sqrt(token1/token0)` 的 Q64.96 定点数表示，既避免浮点数，又让 AMM 数学运算保持线性，是 Uniswap v3/v4 精度与效率的核心设计。
